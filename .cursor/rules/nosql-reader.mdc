# MyNoSql reader integration (my-nosql-data-reader-sdk)

MyNoSql is an internal NoSQL database used for storing settings and similar configuration data.

It is split into two parts:
1. **Reader (TCP)** – connects over TCP and keeps a local in-memory copy of the data inside the service.
2. **Writer (REST API)** – used by other components/administrative tools to write and update models (writer is configured separately).

This document describes **how to use the MyNoSql reader** from inside a service.

---

## 0. Important: use the TCP reader type (avoid wrong paths)

✅ **Always use** `MyNoSqlDataReaderTcp` (TCP reader).  
❌ Do **not** use `MyNoSqlDataReader` in services.

To avoid “wrong path” imports, follow these import patterns:

```rust
use std::sync::Arc;

// Recommended reader import (via service SDK re-export)
use yft_service_sdk::external::my_no_sql_sdk::reader::MyNoSqlDataReaderTcp;

// Your MyNoSql entity types come from a separate models/contracts crate
use cyphertrade_nosql_contracts::xp_progression::XpProgressionSettingsMyNoSqlEntity;
use cyphertrade_nosql_contracts::user_group::UserGroupsNoSqlModel;
```

> The service should obtain readers from `ServiceContext::get_ns_reader::<T>()` and store them in `AppContext`.

---

## 1. When to use the MyNoSql reader

Use the MyNoSql reader when the service needs:
- configuration/reference data that must be **available in memory**, synced from a central MyNoSql instance;
- **fast read access** to settings / reference data;
- data that is naturally modeled as “tables” with partition and row keys.

The reader provides:
- a background-syncing in-memory cache of a table;
- convenient methods for snapshots, partition-based reads, and single-entity reads.

---

## 2. Enabling the reader in a service

### 2.1 Enable the feature in `Cargo.toml`

```toml
[dependencies]
yft-service-sdk = { path = "yft-service-sdk", features = ["my-nosql-data-reader-sdk" /*, other features */] }
```

### 2.2 Ensure the TCP reader setting exists in the service settings model

Example (`src/settings.rs`):

```rust
use yft_service_sdk::external::my_settings_reader;

#[derive(
    Debug,
    Clone,
    serde::Serialize,
    serde::Deserialize,
    yft_service_sdk::macros::SdkSettingsTraits,
    yft_service_sdk::macros::AutoGenerateSettingsTraits,
    yft_service_sdk::external::my_settings_reader::SettingsModel,
)]
pub struct SettingsModel {
    pub logs_host_port: String,

    // required by reader connection wiring
    pub my_no_sql_tcp_reader: String,
}
```

---

## 3. Where the MyNoSql models live

- MyNoSql entity models are defined in **separate libraries** (internal crates/contracts).
- They are **not** defined inside each service.
- When using `get_ns_reader`, you pass the specific entity type from those libraries.

The entity type must implement:

```rust
MyNoSqlEntity + MyNoSqlEntitySerializer + Sync + Send + 'static
```

---

## 4. Getting a reader from ServiceContext

After the feature is enabled and the setting is present, `ServiceContext` exposes a helper:

```rust
#[cfg(feature = "my-nosql-data-reader-sdk")]
pub async fn get_ns_reader<
    TMyNoSqlEntity: my_no_sql_sdk::abstractions::MyNoSqlEntity
        + my_no_sql_sdk::abstractions::MyNoSqlEntitySerializer
        + Sync
        + Send
        + 'static,
>(
    &self,
) -> Arc<my_no_sql_sdk::reader::MyNoSqlDataReaderTcp<TMyNoSqlEntity>> {
    let reader = self.my_no_sql_connection.get_reader().await;
    reader
}
```

**Service-side rule:**  
- Do **not** call `MyNoSqlDataReaderTcp::new(...)` directly in services.
- Always obtain readers via `sc.get_ns_reader::<T>().await`.

---

## 5. Wiring the reader into AppContext (recommended structure)

For each table you want to read from MyNoSql:

### 5.1 Add a field to `AppContext`

```rust
use std::sync::Arc;
use yft_service_sdk::external::my_no_sql_sdk::reader::MyNoSqlDataReaderTcp;

use cyphertrade_nosql_contracts::xp_progression::XpProgressionSettingsMyNoSqlEntity;
use cyphertrade_nosql_contracts::user_group::UserGroupsNoSqlModel;

#[derive(Clone)]
pub struct AppContext {
    pub xp_progression_settings_reader: Arc<MyNoSqlDataReaderTcp<XpProgressionSettingsMyNoSqlEntity>>,
    pub user_groups_reader: Arc<MyNoSqlDataReaderTcp<UserGroupsNoSqlModel>>,

    // ... other dependencies (db pool, repos, grpc clients, etc.)
}
```

### 5.2 Initialize in `AppContext::new` using `ServiceContext::get_ns_reader`

```rust
use yft_service_sdk::ServiceContext;
use std::sync::Arc;

impl AppContext {
    pub async fn new(sc: &ServiceContext, settings_reader: Arc<SettingsReader>) -> Self {
        let xp_progression_settings_reader = sc
            .get_ns_reader::<XpProgressionSettingsMyNoSqlEntity>()
            .await;

        let user_groups_reader = sc
            .get_ns_reader::<UserGroupsNoSqlModel>()
            .await;

        Self {
            xp_progression_settings_reader,
            user_groups_reader,
            // ... initialize other deps
        }
    }
}
```

### 5.3 Use the reader via `AppContext` in flows/services

```rust
pub async fn some_flow(app: &AppContext) -> Result<(), FlowError> {
    let groups = app
        .user_groups_reader
        .get_table_snapshot_as_vec()
        .await
        .unwrap_or_default();

    // business logic using groups
    Ok(())
}
```

---

## 6. Allowed usage by layer

- **Controllers (HTTP/gRPC handlers)**:
  - MUST NOT access `MyNoSqlDataReaderTcp` directly.
  - Work only with DTOs and call flows.

- **Flows (business logic)**:
  - MAY use `MyNoSqlDataReaderTcp` via `AppContext` to read settings / reference data.
  - Should not be aware of connection strings or low-level connection details.

- **Repository / adapter layer**:
  - If needed, wrap MyNoSql reads into a dedicated repository for a specific table.
  - Expose that repo from `AppContext`, and flows call the repo instead of using the raw reader.

**Goal:**
- MyNoSql integration is **hidden behind AppContext** and (optionally) repositories.
- No direct MyNoSql connection logic in controllers or random modules.

---

## 7. Reader API overview and recommended patterns

The reader type:

```rust
impl<TMyNoSqlEntity> MyNoSqlDataReaderTcp<TMyNoSqlEntity>
where
    TMyNoSqlEntity: MyNoSqlEntity + MyNoSqlEntitySerializer + Sync + Send + 'static,
{
    pub async fn get_table_snapshot_as_vec(&self) -> Option<Vec<Arc<TMyNoSqlEntity>>>;

    pub async fn get_by_partition_key_as_vec(
        &self,
        partition_key: &str,
    ) -> Option<Vec<Arc<TMyNoSqlEntity>>>;

    pub async fn get_entity(
        &self,
        partition_key: &str,
        row_key: &str,
    ) -> Option<Arc<TMyNoSqlEntity>>;

    pub async fn has_partition(&self, partition_key: &str) -> bool;

    pub async fn get_partition_keys(&self) -> Vec<String>;

    // (other APIs omitted for brevity)
}
```

### Typical use cases

**Load entire table into memory (small config tables):**
```rust
let items = app
    .xp_progression_settings_reader
    .get_table_snapshot_as_vec()
    .await
    .unwrap_or_default();
```

**Get all entities by partition key:**
```rust
let items = app
    .user_groups_reader
    .get_by_partition_key_as_vec(partition_key)
    .await
    .unwrap_or_default();
```

**Get a single entity:**
```rust
if let Some(entity) = app
    .user_groups_reader
    .get_entity(partition_key, row_key)
    .await
{
    // use entity
}
```

**Check if a partition exists:**
```rust
let exists = app
    .user_groups_reader
    .has_partition(partition_key)
    .await;
```

---

## 8. Rules summary

- ✅ Use **`MyNoSqlDataReaderTcp`** (TCP reader) everywhere in services.
- ✅ Import the reader via:  
  `yft_service_sdk::external::my_no_sql_sdk::reader::MyNoSqlDataReaderTcp`
- ✅ Obtain readers only via:  
  `sc.get_ns_reader::<T>().await`
- ✅ Store readers in `AppContext` and pass `AppContext` into flows.
- ❌ Do not construct readers manually (`MyNoSqlDataReaderTcp::new`) inside services.
- ❌ Controllers must not touch readers directly.

