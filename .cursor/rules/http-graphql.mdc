---
description: HTTP (Axum) and GraphQL (async-graphql) integration
alwaysApply: false
---
# HTTP & GraphQL integration (Axum + async-graphql)

This rule describes how HTTP and GraphQL endpoints are structured and wired
in services using:

- **Axum** for HTTP routes and handlers
- **async-graphql** + `async-graphql-axum` for GraphQL
- `AppContext` as shared application state
- `ServiceContext::init_http_router` for router registration

The goal is to keep transport code thin (adapters only) and push business logic
into flows that work with DTOs and repositories.

---

## 1. HTTP (Axum) structure and conventions

### 1.1. HTTP root folder

All HTTP-specific code lives under:

```text
src/http/
```

For each domain, there is a subfolder:

```text
src/http/<domain_name>/
```

Within that folder:

- `src/http/<domain_name>/http_models.rs` – HTTP request/response models
  (network models: structs used in JSON bodies, query params, etc.).
- One file per endpoint / use case, for example:

```text
src/http/users/http_models.rs
src/http/users/create_user.rs
src/http/users/login_user.rs
src/http/users/get_user.rs
...
```

### 1.2. Axum handlers

Each HTTP method is implemented as an Axum handler function in its own file
(e.g. `create_user.rs`), and **must not** contain complex business logic.

Instead, handlers:

1. Accept HTTP network models and `State<Arc<AppContext>>`.
2. Map network models → DTOs.
3. Call flows (business logic) using `AppContext`.
4. Map flow results (DTOs / errors) back to HTTP responses.

Typical pattern:

```rust
use std::sync::Arc;
use axum::extract::State;
use axum::Json;
use crate::app::AppContext;
use crate::http::users::http_models::{CreateUserHttpRequest, CreateUserHttpResponse};
use crate::flows::users::create_user_flow;

pub async fn create_user(
    State(app_context): State<Arc<AppContext>>,
    Json(payload): Json<CreateUserHttpRequest>,
) -> Result<Json<CreateUserHttpResponse>, axum::http::StatusCode> {
    let dto = payload.into_dto(); // network → DTO (if needed)

    let result = create_user_flow(app_context.as_ref(), dto)
        .await
        .map_err(|err| err.into_http_status())?;

    Ok(Json(CreateUserHttpResponse::from(result)))
}
```

Rules:
- Handlers MUST receive `State<Arc<AppContext>>` for access to flows, repos, clients, etc.
- Handlers MUST delegate to flows instead of embedding business logic.
- DTO mapping and error mapping (to HTTP status codes) live in the HTTP layer.

### 1.3. Registering HTTP routes in main

HTTP routes are registered via `ServiceContext::init_http_router` in `main.rs`.

Example:

```rust
use std::sync::Arc;
use axum::routing::post;
use yft_service_sdk::external::axum::Router;
use crate::app::AppContext;
use crate::http::trading::{update_active, close_active_position, place_order, update_pending, cancel_order};

#[tokio::main]
async fn main() {
    let settings_reader = SettingsReader::new(".my-cfd-platform").await;
    let settings_reader = Arc::new(settings_reader);

    let mut service_context = yft_service_sdk::ServiceContext::new(settings_reader.clone()).await;
    let app_context = Arc::new(AppContext::new(&service_context, settings_reader.clone()).await);

    service_context.init_http_router(
        Router::new()
            .route("/api/trading/active", post(update_active))
            .route("/api/trading/active/close", post(close_active_position))
            .route("/api/trading/order/place", post(place_order))
            .route("/api/trading/order", post(update_pending))
            .route("/api/trading/order/cancel", post(cancel_order))
            .with_state(app_context.clone()),
    );

    service_context.start_application().await;
}
```

Rules:
- All HTTP routes must be registered on a single Axum `Router` passed to `init_http_router`.
- Always attach `with_state(app_context.clone())` so handlers can receive `State<Arc<AppContext>>`.
- Path naming follows `/api/<domain>/<action>` style (confirm exact route with the developer when adding new endpoints).

---

## 2. GraphQL (async-graphql) structure and conventions

GraphQL is implemented using `async-graphql` and `async-graphql-axum`.

### 2.1. GraphQL folder structure

GraphQL code lives under:

```text
src/graphql/
```

(Use the standard spelling: `graphql`.)

For each domain, there is a subfolder:

```text
src/graphql/<domain>/
```

Inside a domain folder:

- `src/graphql/<domain>/domain_query.rs` – GraphQL `Query` root for that domain.
- `src/graphql/<domain>/domain_mutation.rs` – GraphQL `Mutation` root for that domain.
- `src/graphql/<domain>/models/target_models.rs` – GraphQL models/objects/enums for that domain.

Example:

```text
src/graphql/reports/reports_query.rs
src/graphql/reports/reports_mutation.rs
src/graphql/reports/models/report_models.rs
```

Resolvers and models should follow the same layering rules:
- Resolvers call flows using `AppContext`.
- Business logic stays in flows, not inside resolvers.

### 2.2. Building a domain schema

Each domain exposes a function to build its GraphQL schema in:

```text
src/graphql/<domain>/mod.rs
```

Example pattern:

```rust
use async_graphql::{Schema, EmptySubscription};
use crate::graphql::reports::reports_query::ReportsQueryRoot;
use crate::graphql::reports::reports_mutation::ReportsMutationRoot;

pub type ReportsSchema = Schema<ReportsQueryRoot, ReportsMutationRoot, EmptySubscription>;

pub fn get_reports_schema() -> ReportsSchema {
    Schema::build(ReportsQueryRoot, ReportsMutationRoot, EmptySubscription)
        // .data(...) if you want to inject global data
        .finish()
}
```

Naming rules:
- Schema type alias: `<DomainName>Schema` (e.g. `ReportsSchema`).
- Builder function name: `get_<domain_name>_schema` (e.g. `get_reports_schema`).

Resolvers can obtain `AppContext` via data injection or as part of their internal state,
depending on how the schema is wired in the concrete project.

### 2.3. GraphiQL and GraphQL HTTP handlers

Top-level GraphQL HTTP endpoints are defined in:

```text
src/graphql/mod.rs
```

Typical pattern:

```rust
use async_graphql::{
    http::GraphiQLSource,
    Request as GraphQLRequest,
    Response as GraphQLResponse,
};
use async_graphql_axum::GraphQLRequest as AxumGraphQLRequest;
use async_graphql_axum::GraphQLResponse as AxumGraphQLResponse;
use axum::{response, extract::State};
use axum::response::IntoResponse;
use http::HeaderMap;

use crate::graphql::reports::ReportsSchema;
use crate::metrics::{HTTP_REQUESTS_COUNTER, GRAPHQL_REQUESTS_DURATION_HISTORGRAM};
use crate::graphql::RequestHost;

pub async fn graphiql() -> impl IntoResponse {
    response::Html(GraphiQLSource::build().endpoint("/api/reports/ql").finish())
}
```

> Note: the endpoint `"/api/reports/ql"` MUST be confirmed with the developer for each domain.

GraphQL handler with metrics:

```rust
pub async fn graphql_handler(
    State(schema): State<ReportsSchema>,
    headers: HeaderMap,
    req: AxumGraphQLRequest,
) -> AxumGraphQLResponse {
    let req: GraphQLRequest = req.into_inner();
    let host = headers
        .get("host")
        .and_then(|h| h.to_str().ok())
        .unwrap_or_default()
        .to_string();

    let operation_name = req.operation_name.clone().unwrap_or_else(|| "N/A".to_string());

    HTTP_REQUESTS_COUNTER
        .with_label_values(&[&operation_name])
        .inc();

    let start = GRAPHQL_REQUESTS_DURATION_HISTORGRAM
        .with_label_values(&[&operation_name])
        .start_timer();

    let response: GraphQLResponse = schema
        .execute(req.data(RequestHost(host)))
        .await;

    start.observe_duration();
    response.into()
}
```

Rules:
- Use the existing metrics (`HTTP_REQUESTS_COUNTER`, `GRAPHQL_REQUESTS_DURATION_HISTORGRAM`) if they are already defined in the project.
- If they are not present, either:
  - add them following the existing metrics pattern in the repo, or
  - omit metrics but keep the handler structure, depending on team decision.
- Always pass `RequestHost(host)` (or equivalent) via `.data(...)` if the project relies on host information inside resolvers.

### 2.4. Registering GraphQL route in main

Finally, GraphQL HTTP entrypoint is wired in `main.rs` via `init_http_router`.

Example:

```rust
use std::sync::Arc;
use axum::routing::get;
use yft_service_sdk::external::axum::Router;
use crate::graphql::{self, get_reports_schema};
use crate::app::AppContext;

#[tokio::main]
async fn main() {
    let settings_reader = SettingsReader::new(".my-cfd-platform").await;
    let settings_reader = Arc::new(settings_reader);

    let mut service_context = yft_service_sdk::ServiceContext::new(settings_reader.clone()).await;
    let app_context = Arc::new(AppContext::new(&service_context, settings_reader.clone()).await);

    let reports_schema = get_reports_schema();

    service_context.init_http_router(
        Router::new()
            .route(
                "/api/reports/ql",
                get(graphql::graphiql).post(graphql::graphql_handler),
            )
            .with_state(reports_schema)
            .with_state(app_context.clone()),
    );

    service_context.start_application().await;
}
```

Key points:
- The GraphQL endpoint path (e.g. `"/api/reports/ql"`) must match the one used in `graphiql()`.
- The schema (`ReportsSchema`) is provided as Axum state via `.with_state(reports_schema)`.
- `AppContext` can also be provided as state (depending on how resolvers need it). If resolvers already receive everything they need through schema data, you may not need to add `AppContext` as separate state for this router.

---

## 3. Layering and responsibilities for HTTP & GraphQL

- **HTTP handlers (Axum)**:
  - Work only with HTTP network models and `State<Arc<AppContext>>`.
  - Map network models ↔ DTOs and delegate to flows.
  - Map flow errors into HTTP errors (status codes + error bodies).

- **GraphQL resolvers (async-graphql)**:
  - Expose domain operations via `Query`/`Mutation` types.
  - Use `AppContext` and flows to implement business logic.
  - Map between GraphQL models and DTOs/data store results.

- **Flows**:
  - Contain business logic.
  - Use repositories and other services (e.g. gRPC clients, SB, NoSQL, PostgreSQL) via `AppContext`.
  - Are agnostic of HTTP/GraphQL details.

- **Repositories and data store models**:
  - Encapsulate access to PostgreSQL, MyNoSql, etc.
  - Do not know about HTTP or GraphQL.

This keeps HTTP and GraphQL as thin transport layers and prevents leakage of protocol-specific
types into the domain/business logic.
